// lib/data/drift/core_database.dart

import 'package:core/core.dart';
import 'package:core/data/datasources/tables/auth_table.dart'; // berisi UserAuths
import 'package:core/data/models/user_model.dart';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path/path.dart' as p;
import 'package:flutter_bcrypt/flutter_bcrypt.dart';

part 'core_database.g.dart';

@DriftDatabase(tables: [UserAuths])
class CoreDatabaseDrift extends _$CoreDatabaseDrift {
  static CoreDatabaseDrift? _instance;
  final Logger _logger = Logger('CoreDatabaseDrift');

  CoreDatabaseDrift._(QueryExecutor e) : super(e);

  /// Singleton instance (lazy, async-safe)
  static Future<CoreDatabaseDrift> instance() async {
    _instance ??= await _init();
    return _instance!;
  }

  /// Inisialisasi database
  static Future<CoreDatabaseDrift> _init() async {
    // 1. Direktori database
    final dbFolder = await getApplicationSupportDirectory();
    await dbFolder.create(recursive: true);

    // 2. Nama file database
    final version = dotenv.env['VERSION'] ?? 'app';
    final dbName = '${version}_auth.db';
    final dbFile = File(p.join(dbFolder.path, dbName)); // ✅ File, bukan String

    // 3. Executor dengan optimasi
    final executor = NativeDatabase.createInBackground(
      dbFile,
      setup: (db) {
        db.execute('PRAGMA journal_mode=WAL;');
        db.execute('PRAGMA foreign_keys = ON;');
      },
    );

    // 4. Return instance
    return CoreDatabaseDrift._(executor);
  }

  @override
  int get schemaVersion => int.tryParse(dotenv.env['VERSION_DB'] ?? '1') ?? 1;

  @override
  MigrationStrategy get migration => MigrationStrategy(
        onCreate: (Migrator m) => m.createAll(),
        onUpgrade: (Migrator m, int from, int to) async {
          // Contoh: if (from < 2) await m.alterTable(...);
          // Biarkan kosong dulu jika belum ada migrasi
        },
      );

  // ─── DAO Methods ─────────────────────────────────────────────────────

  Future<UserAuth?> getUser() async {
    try {
      final users = await (select(userAuths)..limit(1)).get();
      return users.firstOrNull;
    } catch (e, st) {
      _logger.severe('Error fetching user', e, st);
      return null;
    }
  }

  Future<bool> authUser({
    required String email,
    required String password,
  }) async {
    try {
      final user = await (select(userAuths)
            ..where((t) => t.email.equals(email)))
          .get()
          .then((list) => list.firstOrNull);

      if (user == null || user.password.isEmpty) return false;

      final isValid = await FlutterBcrypt.verify(
        password: password,
        hash: user.password!,
      );
      return isValid;
    } catch (e, st) {
      _logger.severe('Error authenticating user', e, st);
      return false;
    }
  }

  Future<int> countUser() async {
    final result =
        await customSelect('SELECT COUNT(*) AS count FROM user_auths')
            .getSingle();
    return result.data['count'] as int;
  }

  Future<int> storeUser(UserModel user) async {
    await delete(userAuths).go();

    final map = await user.toLocalDbJson(); // pastikan ini Map<String, dynamic>

    final companion = UserAuthsCompanion.insert(
      username: map['username'] != null
          ? Value(map['username'] as String?)
          : const Value.absent(),
      password: map['password'] as String,
      token: map['token'] != null
          ? Value(map['token'] as String?)
          : const Value.absent(),
      email: map['email'] as String,
    );

    return await into(userAuths).insert(companion);
  }

  Future<int> deleteUser() async {
    return await delete(userAuths).go();
  }

  Future<void> deleteToken() async {
    final user = await getUser();
    if (user == null) return;

    await (update(userAuths)..where((t) => t.id.equals(user.id))).write(
      const UserAuthsCompanion(
        token: Value(null),
      ),
    );
  }
}
